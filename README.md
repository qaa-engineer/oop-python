# oop-python
Инкапсуляция, наследование, полиморфизм в Python

<div class="section" id="id2"><h2>Инкапсуляция</h2><p>Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным). Инкапсуляция делает некоторые из компонент доступными только внутри класса.</p><p>Инкапсуляция в Python работает лишь на уровне соглашения между программистами о том, какие атрибуты являются общедоступными, а какие — внутренними.</p><p>Одиночное подчеркивание в начале имени атрибута говорит о том, что переменная или метод не предназначен для использования вне методов класса, однако атрибут доступен по этому имени.</p><pre class="code python3"><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_private</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Это приватный метод!"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">_private</span><span class="p">()</span>
<span class="n">Это</span> <span class="n">приватный</span> <span class="n">метод</span><span class="err">!</span></pre><p>Двойное подчеркивание в начале имени атрибута даёт большую защиту: атрибут становится недоступным по этому имени.</p><div class="highlight-python3" style="position: relative;"><div class="highlight"><span class="copybutton" title="Убрать приглашения и вывод программы">&gt;&gt;&gt;</span><pre class="code pycon literal-block"><span class="k"></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__private</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">"Это приватный метод!"</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">__private</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):
</span><span>  File </span><span class="nb">"&lt;stdin&gt;"</span><span>, line </span><span class="m">1</span><span>, in </span><span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span><span>: </span><span class="n">'B' object has no attribute '__private'</span></pre></div></div><p>Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем _ИмяКласса__ИмяАтрибута:</p><div class="highlight-python3" style="position: relative;"><div class="highlight"><span class="copybutton" title="Убрать приглашения и вывод программы">&gt;&gt;&gt;</span><pre class="code pycon literal-block"><span class="n"></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">_B__private</span><span class="p">()</span>
<span class="go">Это приватный метод!</span></pre></div></div></div><div class="section" id="id3"><h2>Наследование</h2><p>Наследование подразумевает то, что дочерний класс содержит все атрибуты родительского класса, при этом некоторые из них могут быть переопределены или добавлены в дочернем. Например, мы можем создать свой класс, похожий на <a href="https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html" target="_blank">словарь</a>:</p><div class="highlight-python3" style="position: relative;"><div class="highlight"><span class="copybutton" title="Убрать приглашения и вывод программы" style="text-decoration: none;">&gt;&gt;&gt;</span><pre class="code pycon literal-block"><span class="k"></span><span class="gp" style="">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Mydict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp" style="">... </span>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="gp" style="">... </span>        <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
<span class="gp" style="">...</span>
<span class="gp" style="">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp" style="">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Mydict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></pre></div></div><p>Класс Mydict ведёт себя точно так же, как и словарь, за исключением того, что метод get по умолчанию возвращает не None, а 0.</p><div class="highlight-python3" style="position: relative;"><div class="highlight"><span class="copybutton" title="Убрать приглашения и вывод программы">&gt;&gt;&gt;</span><pre class="code pycon literal-block"><span class="n"></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">'c'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">{'a': 1, 'c': 4, 'b': 2}
</span><span class="nb"></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'v'</span><span class="p">))</span>
<span class="go">None
</span><span class="nb"></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'v'</span><span class="p">))</span>
<span class="go">0</span></pre></div></div></div><div class="section" id="id4"><h2>Полиморфизм</h2><p>Полиморфизм - разное поведение одного и того же метода в разных классах. Например, мы можем сложить два числа, и можем сложить две строки. При этом получим разный результат, так как числа и строки являются разными классами.</p><div class="highlight-python3" style="position: relative;"><div class="highlight"><span class="copybutton" title="Убрать приглашения и вывод программы">&gt;&gt;&gt;</span><pre class="code pycon literal-block"><span class="mi"></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">2
</span><span class="s2"></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">"1"</span> <span class="o">+</span> <span class="s2">"1"</span>
<span class="go">'11'</span></pre></div></div></div></div>
